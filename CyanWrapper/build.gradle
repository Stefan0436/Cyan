buildscript {
	repositories {
		mavenCentral()
		maven {
			name = "AerialWorks"; url = "https://aerialworks.ddns.net/maven"
		}
	}
	dependencies {
		classpath 'org.asf.cyan.cornflower:Cornflower:1.0.0.A35'
	}
}

plugins {
	id 'java'
	id 'maven-publish'
}

apply plugin: 'eclipse'
apply plugin: 'org.asf.cyan.cornflower'

apply from: '../KickStartInstallerJarTask.gradle'

import sun.security.ec.point.ProjectivePoint
import java.time.OffsetDateTime

import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream

import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.ParserConfigurationException

import java.util.zip.ZipInputStream

import java.nio.file.*
import java.security.MessageDigest
import java.math.BigInteger
import java.util.jar.Manifest;
import java.util.jar.Attributes;
import com.google.gson.Gson
import com.google.gson.JsonParser
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import com.google.gson.JsonArray

import org.asf.cyan.cornflower.gradle.Cornflower
import org.asf.cyan.minecraft.toolkits.mtk.MinecraftModdingToolkit
import org.asf.cyan.minecraft.toolkits.mtk.MinecraftToolkit
import org.asf.cyan.minecraft.toolkits.mtk.MinecraftVersionToolkit
import org.asf.cyan.minecraft.toolkits.mtk.MinecraftMappingsToolkit
import org.asf.cyan.minecraft.toolkits.mtk.versioninfo.MinecraftVersionInfo
import org.w3c.dom.Document
import org.w3c.dom.Element
import org.w3c.dom.NodeList
import org.xml.sax.SAXException
import org.asf.cyan.minecraft.toolkits.mtk.MinecraftInstallationToolkit
import org.asf.cyan.cornflower.gradle.utilities.Log4jToGradleAppender
import org.asf.cyan.core.CyanCore
import org.asf.cyan.api.modloader.information.game.GameSide
import org.asf.cyan.minecraft.toolkits.mtk.versioninfo.MinecraftVersionType

apply from: '../config.gradle'
sourceCompatibility = '1.9'
targetCompatibility = '1.9'

File cyanCache = new File(getCacheRoot(), "cyan-wrapper-project");
if (!cyanCache.exists()) cyanCache.mkdirs();

if (file("../modloaderbuild.gradle").exists()) {
	ext.stabilityValue = 'testing'
	ext.stability = { t ->
		ext.stability = t;
	}
	
	ext.forgeVersions = [:]
	ext.forge = { ... t ->
		for (def ver : t) {
			File forgeInstaller = new File(cyanCache, "forge-" + minecraft + "-" + ver + "-installer.jar")
			File downloadmarker = new File(cyanCache, forgeInstaller.getName()+".lck")
			URL url = new URL(forgeurltemplate.replaceAll("\\%game\\%", minecraft).replaceAll("\\%forgeversion\\%", ver))
			if (!forgeInstaller.exists() || downloadmarker.exists()) {
				if (!forgeInstaller.getParentFile().exists())
					forgeInstaller.getParentFile().mkdirs()
				if (downloadmarker.exists()) downloadmarker.delete()
				downloadmarker.createNewFile()
		
				println "Downloading forge installer to cache..."
				if (forgeInstaller.exists()) forgeInstaller.delete()
				FileOutputStream strm = new FileOutputStream(forgeInstaller);
				InputStream inp = url.openStream()
				inp.transferTo(strm)
				strm.close()
				inp.close()
				downloadmarker.delete()
			}
		
			println "Searching for MCP version in forge jar..."
			String mcpVersion = "";
			ZipFile installerZip = new ZipFile(forgeInstaller);
			ZipEntry forgeJar = installerZip.getEntry("maven/net/minecraftforge/forge/" + minecraft + "-" + ver + "/forge-" + minecraft + "-" + ver + ".jar");
			ZipInputStream forgeStrm = new ZipInputStream(installerZip.getInputStream(forgeJar));
			while (forgeStrm.available() != 0) {
				ZipEntry entry = forgeStrm.getNextEntry();
				if (entry.getName().equals("META-INF/MANIFEST.MF")) {
					Manifest manifest = new Manifest(forgeStrm);
					Attributes MCP = manifest.getAttributes("net/minecraftforge/versions/mcp/");
					mcpVersion = MCP.getValue("Implementation-Version");
					break;
				}
			}
			forgeStrm.close();
			installerZip.close();
			forgeVersions.put(ver, mcpVersion);
		}
	}
	
	ext.paperVersions = [:]
	ext.paper = { Map t ->
		paperVersions.putAll(t);
	}
	
	ext.fabricVersions = [:]
	ext.fabric = { Map t ->
		fabricVersions.putAll(t);
	}
	
	apply from: "../modloaderbuild.gradle"
	if (ext.stability.equals("latest")) {
		ext.addToLatest = "true";				
	} else if (ext.stability.equals("stable")) {
		ext.addToStable = "true";		
	} else if (ext.stability.equals("lts")) {
		ext.LTS = "true";
	}
	println paperVersions
}

import org.asf.cyan.api.config.Configuration;
public class CyanUpdateInfo extends Configuration<CyanUpdateInfo> {
	public String latestStableVersion;
	public String latestAlphaVersion;
	public String latestBetaVersion;
	public String latestPreviewVersion;

	public String[] longTermSupportVersions;
	public String[] requiredUpgrade;

	public HashMap<String, String> libraryVersions = new HashMap<String, String>();

	public HashMap<String, String> changelogs = new HashMap<String, String>();
	public HashMap<String, String> allVersions = new HashMap<String, String>();
	public HashMap<String, String> byGameVersions = new HashMap<String, String>();

	public HashMap<String, String> forgeSupport = new HashMap<String, String>();
	public HashMap<String, String> fabricSupport = new HashMap<String, String>();
	public HashMap<String, String> paperSupport = new HashMap<String, String>();


	public HashMap<String, String> paperByMappings = new HashMap<String, String>();

	public HashMap<String, String> spigotStableMappings = new HashMap<String, String>();
	public HashMap<String, String> spigotLatestMappings = new HashMap<String, String>();
	public HashMap<String, String> spigotTestingMappings = new HashMap<String, String>();
	
	public HashMap<String, String> yarnMappings = new HashMap<String, String>();
	public HashMap<String, String> spigotMappings = new HashMap<String, String>();

	public CyanUpdateInfo(String content) {
		readAll(content);
	}

	@Override
	public String filename() {
		return null;
	}

	@Override
	public String folder() {
		return null;
	}
}

def infoPath = "/org/asf/cyan/CyanVersionHolder/generic/CyanVersionHolder-generic-versions.ccfg";

public String getLatestYarnVersion(String version) throws IOException {
	if (!MinecraftToolkit.hasMinecraftDownloadConnection())
		throw new IOException("No network connection");

	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	DocumentBuilder builder;
	String mappingsVersion = "";
	try {
		String mapping = "";
		builder = factory.newDocumentBuilder();
		Document document = builder.parse(new URL("https://maven.modmuss50.me/net/fabricmc/yarn/maven-metadata.xml").openStream());
		Element root = document.getDocumentElement();
		NodeList versions = ((Element) root.getElementsByTagName("versioning").item(0))
				.getElementsByTagName("versions").item(0).getChildNodes();
		for (int i = 0; i < versions.getLength(); i++) {
			if (!versions.item(i).hasChildNodes())
				continue;
			String mapVer = versions.item(i).getFirstChild().getNodeValue();
			if (mapVer.startsWith(version + ".") || mapVer.startsWith(version + "+")) {
				mapping = mapVer;
			}
		}
		if (mapping != "") {
			mappingsVersion = mapping;
		}
	} catch (ParserConfigurationException | SAXException | IOException e) {
		throw new IOException(e);
	}
	return mappingsVersion;
}

if (!ext.hasProperty("mappingsVersion"))
	ext.mappingsVersion = minecraft
if (project.hasProperty("overrideMappingsVersion"))
	mappingsVersion = project.getProperty("overrideMappingsVersion")

ext.craftBukkitPOMUrl = "https://hub.spigotmc.org/stash/projects/SPIGOT/repos/craftbukkit/raw/pom.xml?at=%commit%"
ext.spigotInfoUrl = "https://hub.spigotmc.org/versions/%mcver%.json";

project(":").childProjects.each { proj ->
	if (!proj.value.name.equals(project.name) && !proj.value.name.equals("CyanLoader") && !proj.value.name.contains("CyanAPI") && !proj.value.name.contains("ModKit")) {
		project.evaluationDependsOn ":" + proj.value.name
	}
}

def fallback_url="https://aerialworks.ddns.net/maven"

def netTestUrl = fallback_url
def getServerConnection = {
	->
	try {
		URL u = new URL(netTestUrl);
		URLConnection uc = u.openConnection();
		uc.connect();
		return true;
	} catch (MalformedURLException e) {
		return false;
	} catch (IOException e) {
		return false;
	}
}

if (project.hasProperty("overrideCyanLibraryURL")) {
	fallback_url=project.getProperty("overrideCyanLibraryURL")
}

if (modloader.startsWith("forge-")) {
    def forgeversion = modloader.substring("forge-".length())
    File forgeInstaller = new File(cyanCache, "forge-"+minecraft+"-"+forgeversion+"-installer.jar")
    File downloadmarker = new File(cyanCache, forgeInstaller.getName()+".lck")
    URL url = new URL(forgeurltemplate.replaceAll("\\%game\\%", minecraft).replaceAll("\\%forgeversion\\%", forgeversion))
    if (!forgeInstaller.exists() || downloadmarker.exists()) {
        if (!forgeInstaller.getParentFile().exists())
            forgeInstaller.getParentFile().mkdirs()
        if (downloadmarker.exists()) downloadmarker.delete()
        downloadmarker.createNewFile()

        println "Downloading forge installer to cache..."
        if (forgeInstaller.exists()) forgeInstaller.delete()
        FileOutputStream strm = new FileOutputStream(forgeInstaller);
        InputStream inp = url.openStream()
        inp.transferTo(strm)
        strm.close()
        inp.close()
        downloadmarker.delete()
    }

    println "Searching for MCP version in forge jar..."
    String mcpVersion = "";
    ZipFile installerZip = new ZipFile(forgeInstaller);
    ZipEntry forgeJar = installerZip.getEntry("maven/net/minecraftforge/forge/" + minecraft + "-" + forgeversion + "/forge-" + minecraft + "-" + forgeversion + ".jar");
    ZipInputStream forgeStrm = new ZipInputStream(installerZip.getInputStream(forgeJar));
    while (forgeStrm.available() != 0) {
        ZipEntry entry = forgeStrm.getNextEntry();
        if (entry.getName().equals("META-INF/MANIFEST.MF")) {
            Manifest manifest = new Manifest(forgeStrm);
            Attributes MCP = manifest.getAttributes("net/minecraftforge/versions/mcp/");
            mcpVersion = MCP.getValue("Implementation-Version");
            break;
        }
    }
    forgeStrm.close();
    installerZip.close();
    if (!project.hasProperty("overrideMappingsVersion"))
        mappingsVersion = mcpVersion;
} else if (modloader.startsWith("fabric-loader-")) {
    if (!project.hasProperty("overrideMappingsVersion")) {
		def loaderVersion = modloader.substring("fabric-loader-".length())
        println "Resolving latest YARN mappings..."
		def mappingsASFSupported = null		
		
		def useurl = fallback_url
		if (fallback_url.equals(""))
			useurl = netTestUrl
	
		try {
			StringBuilder conf = new StringBuilder();
			URL u = new URL(useurl + infoPath);
			Scanner sc = new Scanner(u.openStream());
			while (sc.hasNext())
				conf.append(sc.nextLine() + System.lineSeparator());
			sc.close();
	
			CyanUpdateInfo info = new CyanUpdateInfo(conf.toString())
			if (info.yarnMappings.containsKey(minecraft+"-"+loaderVersion))
				mappingsASFSupported = info.yarnMappings.get(minecraft+"-"+oaderVersion)
		} catch (Exception e) {
			
		}
		
		if (mappingsASFSupported == null) {
		    String version = getLatestYarnVersion(minecraft)
		    mappingsVersion = version
		} else {
			mappingsVersion = mappingsASFSupported
		}
    }
}

private JsonObject getRefs(String version) throws IOException {
	if (!MinecraftToolkit.hasMinecraftDownloadConnection())
		throw new IOException("No network connection");

	URL infoURL = new URL(spigotInfoUrl.replaceAll("\\%mcver\\%", version));

	InputStream info = infoURL.openStream();
	JsonObject obj = JsonParser.parseReader(new InputStreamReader(info)).getAsJsonObject();
	info.close();

	return obj.get("refs").getAsJsonObject();
}

public String getLatestSpigotMappings(String version) throws IOException {
	JsonObject refs = getRefs(version);
	String commit = refs.get("BuildData").getAsString();

	URL u = new URL(craftBukkitPOMUrl.replaceAll("\\%mcver\\%", version).replaceAll("\\%commit\\%",
			getRefs(version).get("CraftBukkit").getAsString()));

	String craftBukkitVersion = "";
	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	DocumentBuilder builder;
	try {
		builder = factory.newDocumentBuilder();
		Document document = builder.parse(u.openStream());
		Element root = document.getDocumentElement();
		craftBukkitVersion = ((Element) root.getElementsByTagName("properties").item(0))
				.getElementsByTagName("minecraft_version").item(0).getChildNodes().item(0).getNodeValue();
	} catch (ParserConfigurationException | SAXException | IOException e) {
		throw new IOException(e);
	}

	return commit + ":" + craftBukkitVersion;
}


buildDir = '../build/Wrapper'

group="org.asf.cyan"
def cyanloader_logconf_version=cyanversion
def cyanloader_package="org.asf.cyan.CyanLoader"
def authorname="AerialWorks Software Foundation"

if (project.hasProperty("logXMLLoaderVersion")) {
	cyanloader_logconf_version=project.getProperty("logXMLLoaderVersion")
}

def classWrapperClient="CyanClientWrapper"
def classWrapperServer="CyanServerWrapper"

if (project.hasProperty("overrideLaunchWrapperClient")) {
	classWrapperClient=project.getProperty("overrideLaunchWrapperClient")
}

if (project.hasProperty("overrideLaunchWrapperServer")) {
	classWrapperServer=project.getProperty("overrideLaunchWrapperServer")
}

version="1.0.0.A9-cyan-"+cyanversion

def timeStartHuman=OffsetDateTime.parse("${timeStartDev}").withNano(0).toLocalDate().toString()+" at "+OffsetDateTime.parse("${timeStartDev}").withNano(0).toLocalTime().toString();
def timeReleaseHuman=OffsetDateTime.parse("${timeRelease}").withNano(0).toLocalDate().toString()+" at "+OffsetDateTime.parse("${timeRelease}").withNano(0).toLocalTime().toString();

cyanloader_package = cyanloader_package.replaceAll("\\.","/")

jar.dependsOn('processResources')

repositories {
	mavenCentral()
	maven {
		url = 'https://repo.spongepowered.org/maven'
	}
	maven {
		name = "AerialWorks"; url = "https://aerialworks.ddns.net/maven"
	}
}

configurations {
	wrapper
	testWrapper
}

dependencies {
	wrapper 'org.reflections:reflections:0.9.12'
	implementation 'org.reflections:reflections:0.9.12'

	testImplementation 'junit:junit:4.12'
	testWrapper 'org.asf.software:SideTerminal:1.0.0.A3'

	//	wrapper "org.spongepowered:mixin:${mixinversion}"
	//	implementation "org.spongepowered:mixin:${mixinversion}"

	wrapper 'org.asf.aos.util.service:aosutil-service-SLIB-UTIL:0.0.0.13'
	implementation 'org.asf.aos.util.service:aosutil-service-SLIB-UTIL:0.0.0.13'

	wrapper 'org.ow2.asm:asm:9.1'
	implementation 'org.ow2.asm:asm:9.1'

	wrapper 'org.ow2.asm:asm-tree:9.1'
	implementation 'org.ow2.asm:asm-tree:9.1'

	wrapper 'org.ow2.asm:asm-commons:9.1'
	implementation 'org.ow2.asm:asm-commons:9.1'

	wrapper group: 'org.ow2.asm', name: 'asm-util', version: '9.1'
	wrapper group: 'org.ow2.asm', name: 'asm-analysis', version: '9.1'
	implementation group: 'org.ow2.asm', name: 'asm-analysis', version: '9.1'
	implementation group: 'org.ow2.asm', name: 'asm-util', version: '9.1'

	wrapper group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.14.0'
	wrapper group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.14.0'
	implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.14.0'
	implementation group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.14.0'
	
	wrapper project(":CCFG")
	implementation project(":CCFG")

	wrapper project(':Fluid')
	implementation project(':Fluid')

	wrapper project(":CyanComponents")
	implementation project(":CyanComponents")

	wrapper project(":CyanCore")
	implementation project(":CyanCore")

	wrapper project(":CyanUtil")
	implementation project(":CyanUtil")

	wrapper project(":CyanLoader")
	implementation project(":CyanLoader")

	wrapper project(":MTK")
	implementation project(":MTK")

	wrapper project(":ClassTrust")
	implementation project(":ClassTrust")

	wrapper group: 'com.google.code.gson', name: 'gson', version: '2.8.6'
	implementation group: 'com.google.code.gson', name: 'gson', version: '2.8.6'

	wrapper group: 'org.apache.logging.log4j', name: 'log4j-slf4j18-impl', version: '2.14.1'
	wrapper group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.14.1'
	wrapper group: 'org.slf4j', name: 'slf4j-api', version: '1.8.0-beta4'
	implementation group: 'org.apache.logging.log4j', name: 'log4j-slf4j18-impl', version: '2.14.1'
	implementation group: 'org.fusesource.jansi', name: 'jansi', version: '2.3.2'

	wrapper group: 'org.fusesource.jansi', name: 'jansi', version: '2.3.2'
	wrapper group: 'org.jboss.windup.decompiler', name: 'decompiler-fernflower', version: '5.1.2.Final'
	wrapper group: 'org.jboss.windup.decompiler.fernflower', name: 'windup-fernflower', version: '1.0.0.20171018'
	wrapper group: 'org.jboss.windup.decompiler', name: 'decompiler-api', version: '5.1.2.Final'
	wrapper group: 'org.jboss.windup.utils', name: 'windup-utils', version: '5.1.2.Final'
	implementation group: 'org.jboss.windup.decompiler', name: 'decompiler-fernflower', version: '5.1.2.Final'

	wrapper 'org.javassist:javassist:3.27.1-ASF-SNAPSHOT-5'
	implementation (project(':ModKit')) {
        exclude group: '', module: 'server'
        exclude group: '', module: 'client'
	}

	// wrapper project(":MixinSupport")
	// implementation project(":MixinSupport")
}

jar {
	destinationDirectory = file('../build/Wrapper/Jars')
	manifest {
		attributes([
			"Specification-Title": project.name,
			"Specification-Vendor": "${authorname}",
			"Specification-Version": project.version,
			"Implementation-Title": project.name,
			"Implementation-Version": project.version,
			"Implementation-Vendor" :"${authorname}",
			"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
		])
	}
	exclude "**/extra/**"
	exclude "**/tests/**"
	exclude "**/version-launcher.json"
	exclude "**/versions.ccfg"
	exclude "**/version-dbg.json"
	includeEmptyDirs = false
}

task javaDocs(type: Javadoc) {
	classpath = sourceSets.main.runtimeClasspath
	source = sourceSets.main.allJava
}

task javadocJar(type: Jar, dependsOn: 'javaDocs') {
	from javadoc
	classifier = 'javadoc'
	exclude "**/extra/**"
	destinationDirectory = file('../build/Wrapper/Javadocs')
}

task sourcesJar(type: Jar, dependsOn: classes) {
	classifier = 'sources'
	from sourceSets.main.allSource
	exclude "**/extra/**"
	destinationDirectory = file('../build/Wrapper/Source jars')
}

artifacts {
	archives sourcesJar
	archives javadocJar
}

test {
	include "**/**Test**"
	exclude "**/**SpecialTest**"
	minHeapSize = "128m"
	maxHeapSize = "2G"
}
task specialTest (type: Test, dependsOn: test) {
	include "**/**SpecialTest**"
	minHeapSize = "128m"
	maxHeapSize = "2G"
}

def libraries = [
	(project.group+":"+project.name+":"+project.version): tasks.jar.archivePath
]

if (!fallback_url.equals("") && !fallback_url.endsWith("/")) fallback_url+="/"

def librarysources = [
	(project.group+":"+project.name+":"+project.version): fallback_url
]
File libSourceCache = new File(cyanCache, "libraries.sources");
if (libSourceCache.exists() && !project.hasProperty("resetLibSourceCache")) {
	for (String line : Files.readAllLines(libSourceCache.toPath())) {
		def key = line.substring(0, line.indexOf(" = "));
		def url = line.substring(line.indexOf(" = ")+3);
		configurations.wrapper.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
			def lpath = (!dep.moduleGroup.isEmpty() ? dep.moduleGroup+":" : "")+dep.moduleName+(!dep.moduleVersion.isEmpty() ? ":"+dep.moduleVersion : "")
			if (lpath.equals(key)) {
				librarysources.put(key, url)
				println "Loaded source url "+url+" from cache, library: "+key
			}
		}
	}
}

for (def repo : project.repositories) {
	if (repo.getName().equals("AerialWorks")) continue;
	configurations.wrapper.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
		def lpath = (!dep.moduleGroup.isEmpty() ? dep.moduleGroup+":" : "")+dep.moduleName+(!dep.moduleVersion.isEmpty() ? ":"+dep.moduleVersion : "")
		if (!librarysources.containsKey(lpath) && !(repo instanceof FlatDirectoryArtifactRepository)) {
			def path = (!dep.moduleGroup.isEmpty() ? dep.moduleGroup.replaceAll("\\.", "/")+"/" : "")+dep.moduleName+(!dep.moduleVersion.isEmpty() ? "/"+dep.moduleVersion : "")+"/"+dep.getModuleArtifacts()[0].file.getName()
			def url = repo.getUrl().toString()+"/"+path
			try {
				URL u = new URL(url);
				HttpURLConnection connection = (HttpURLConnection)u.openConnection()
				connection.setRequestMethod("GET");
				connection.connect()
				if (connection.responseCode == 200) {
					url=repo.getUrl().toString()
					if (!url.endsWith("/")) url+="/"

					println "Cached source url: "+url+", library: "+lpath
					librarysources.put(lpath, url)
					connection.disconnect()
				}
				connection.disconnect()
			} catch (Exception e) {
				println e
			}
		}
	}
}
configurations.wrapper.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
	def lpath = (!dep.moduleGroup.isEmpty() ? dep.moduleGroup+":" : "")+dep.moduleName+(!dep.moduleVersion.isEmpty() ? ":"+dep.moduleVersion : "")
	if (!librarysources.containsKey(lpath)) {
		librarysources.put(lpath, fallback_url)
		println "Cached source url: "+fallback_url+", library: "+lpath
	}
}
String filedata = "";
librarysources.each { k, v ->
	filedata += k+" = "+v+System.lineSeparator();
}
Files.writeString(libSourceCache.toPath(), filedata)

println ""

def index=0
configurations.wrapper.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
	def path = (!dep.moduleGroup.isEmpty() ? dep.moduleGroup+":" : "")+dep.moduleName+(!dep.moduleVersion.isEmpty() ? ":"+dep.moduleVersion : "")
	libraries.put path, dep.getModuleArtifacts()[0].file
	index++
}

def template="\t\t{"+System.lineSeparator()+
		"\t\t\t"+'"name": "%lib%",'+System.lineSeparator()+
		"\t\t\t"+'"url": "%url%"'+System.lineSeparator()+
		"\t\t}"

import java.security.MessageDigest
def calcSha1(file) // credits to dagezi: https://gist.github.com/dagezi/9594839
{
	MessageDigest md = MessageDigest.getInstance("SHA-1");
	file.eachByte 4096, {bytes, size ->
		md.update(bytes, 0, size);
	}
	return md.digest().encodeHex();
}

def libsMC = new HashMap<File, File>()
def libsTest = new HashMap<File, File>()
configurations.wrapper.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
	if (dep.getModuleArtifacts().size() > 0) {
		File source = null
		File lib = null
		boolean add = true

		project(":").childProjects.each { proj ->
			if (dep.moduleGroup.equals(proj.value.group) && dep.moduleName.equals(proj.value.name) && dep.moduleVersion.equals(proj.value.version)) {
				add = false
			}
		}

		if (add) {
			for (def artifact : dep.getModuleArtifacts()) {
				if (artifact.classifier != null && artifact.classifier.equals("sources"))
					source = artifact.file
				else if (artifact.classifier == null) {
					lib = artifact.file
				}
			}
		}

		if (source == null && lib != null && add) {
			def str = lib.getName()
			if (str.endsWith(".jar") || str.endsWith(".jar"))
				str = str.substring(0, str.lastIndexOf("."))
			if (new File(lib.getParentFile(), str+"-sources.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-sources.jar")
			} else if (new File(lib.getParentFile(), str+"-src.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-src.jar")
			} else if (new File(lib.getParentFile(), str+"-Sources.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-Sources.jar")
			} else if (new File(lib.getParentFile(), str+"-Src.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-Src.jar")
			} else {
				def file = lib.getParentFile().getParentFile()
				if (file != null) {
					for (File dir : file.listFiles(new FileFilter() {
								@Override
								public boolean accept(File f2) {
									return f2.isDirectory()
								}
							})) {
						file = dir
						if (new File(file, str+"-sources.jar").exists()) {
							source = new File(file, str+"-sources.jar")
						} else if (new File(file, str+"-src.jar").exists()) {
							source = new File(file, str+"-src.jar")
						} else if (new File(file, str+"-Sources.jar").exists()) {
							source = new File(file, str+"-Sources.jar")
						} else if (new File(file, str+"-Src.jar").exists()) {
							source = new File(file, str+"-Src.jar")
						} else {
							continue
						}
						break
					}
				}
			}
		}

		if (lib != null && add) {
			libsMC.put(lib, source)
		}
	}
}
configurations.testWrapper.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
	if (dep.getModuleArtifacts().size() > 0) {
		File source = null
		File lib = null
		boolean add = true

		project(":").childProjects.each { proj ->
			if (dep.moduleGroup.equals(proj.value.group) && dep.moduleName.equals(proj.value.name) && dep.moduleVersion.equals(proj.value.version)) {
				add = false
			}
		}

		if (add) {
			for (def artifact : dep.getModuleArtifacts()) {
				if (artifact.classifier != null && artifact.classifier.equals("sources"))
					source = artifact.file
				else if (artifact.classifier == null) {
					lib = artifact.file
				}
			}
		}

		if (source == null && lib != null && add) {
			def str = lib.getName()
			if (str.endsWith(".jar") || str.endsWith(".jar"))
				str = str.substring(0, str.lastIndexOf("."))
			if (new File(lib.getParentFile(), str+"-sources.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-sources.jar")
			} else if (new File(lib.getParentFile(), str+"-src.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-src.jar")
			} else if (new File(lib.getParentFile(), str+"-Sources.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-Sources.jar")
			} else if (new File(lib.getParentFile(), str+"-Src.jar").exists()) {
				source = new File(lib.getParentFile(), str+"-Src.jar")
			} else {
				def file = lib.getParentFile().getParentFile()
				if (file != null) {
					for (File dir : file.listFiles(new FileFilter() {
								@Override
								public boolean accept(File f2) {
									return f2.isDirectory()
								}
							})) {
						file = dir
						if (new File(file, str+"-sources.jar").exists()) {
							source = new File(file, str+"-sources.jar")
						} else if (new File(file, str+"-src.jar").exists()) {
							source = new File(file, str+"-src.jar")
						} else if (new File(file, str+"-Sources.jar").exists()) {
							source = new File(file, str+"-Sources.jar")
						} else if (new File(file, str+"-Src.jar").exists()) {
							source = new File(file, str+"-Src.jar")
						} else {
							continue
						}
						break
					}
				}
			}
		}

		if (lib != null && add) {
			libsTest.put(lib, source)
		}
	}
}

createEclipseLaunches {
	disable = true;
}
createEclipseLaunches.dependsOn 'processResources'
createEclipseLaunches.dependsOn tasks.getByPath(":Fluid:jar")
createEclipseLaunches.dependsOn 'eclipse'

task createDeobfLaunch (type: EclipseLaunchGenerator) {
	name "Launch Cyan " + minecraft + " (Deobfuscated)"
	jvm "-Dcyan.deobfuscated=true"
	jvm "-Dcyan.side=CLIENT"
	doFirst {
		Log4jToGradleAppender.logInfo()
		MinecraftInstallationToolkit.setIDE()

		MinecraftVersionInfo version = MinecraftVersionToolkit.getVersion(minecraft)
		if (!MinecraftInstallationToolkit.checkVersion(version))
			MinecraftInstallationToolkit.downloadVersionAndLibraries(version)
		if (MinecraftInstallationToolkit.getVersionJar(version, GameSide.CLIENT) == null)
			MinecraftInstallationToolkit.downloadVersionJar(version, GameSide.CLIENT)
		if (!MinecraftMappingsToolkit.areMappingsAvailable(version, GameSide.CLIENT)) {
			MinecraftMappingsToolkit.downloadVanillaMappings(version, GameSide.CLIENT)
			MinecraftMappingsToolkit.saveMappingsToDisk(version, GameSide.CLIENT)
		}
		MinecraftMappingsToolkit.loadMappings(version, GameSide.CLIENT)
		MinecraftInstallationToolkit.extractNatives(version)

		mainClass "org.asf.software.sideterminal.SideTermMain"

		File jar = MinecraftModdingToolkit.deobfuscateJar(version, GameSide.CLIENT)
		classpath jar
		
		libsMC.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}
		libsTest.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}

		project(":").childProjects.each { proj ->
			classpath proj.value
		}

		classpath MinecraftInstallationToolkit.getLibraries(version)
		sourceLookup MinecraftModdingToolkit.sourcesJar(version, GameSide.CLIENT)

		workingDir new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "clients/cyan/"+minecraft)

		jvm "-DassetRoot="+MinecraftInstallationToolkit.getAssetsRoot().getCanonicalPath()
		jvm "-DassetIndex="+MinecraftInstallationToolkit.getAssetId(version)
		jvm "-DcyanAgentJar="+project(':Fluid').tasks.jar.archivePath.getCanonicalPath()
		jvm "-Djdk.attach.allowAttachSelf=true"
		jvm "-Dcyancore.resourceloader.rewriteresource.org.asf.cyan.core.CyanInfo.source="+project(":CyanCore").sourceSets.main.output.resourcesDir.getCanonicalPath()
		jvm MinecraftInstallationToolkit.generateJvmArguments(version, null,
				new File[0], MinecraftInstallationToolkit.getNativesDirectory(version), jar, null, false)
		argument project.group+".CyanIDEWrapper"
		
		Log4jToGradleAppender.noLogInfo()
	}
}

task createObfusLaunch (type: EclipseLaunchGenerator) {
	name "Launch Cyan " + minecraft + " (Obfuscated)"
	jvm "-Dcyan.deobfuscated=false"
	jvm "-Dcyan.side=CLIENT"
	doFirst {
		Log4jToGradleAppender.logInfo()
		MinecraftInstallationToolkit.setIDE()

		MinecraftVersionInfo version = MinecraftVersionToolkit.getVersion(minecraft)
		if (!MinecraftInstallationToolkit.checkVersion(version))
			MinecraftInstallationToolkit.downloadVersionAndLibraries(version)
		if (MinecraftInstallationToolkit.getVersionJar(version, GameSide.CLIENT) == null)
			MinecraftInstallationToolkit.downloadVersionJar(version, GameSide.CLIENT)
		MinecraftInstallationToolkit.extractNatives(version)

		mainClass "org.asf.software.sideterminal.SideTermMain"
		argument project.group+".CyanIDEWrapper"

		File jar = MinecraftInstallationToolkit.getVersionJar(version, GameSide.CLIENT)
		classpath jar
		
		libsMC.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}
		libsTest.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}

		project(":").childProjects.each { proj ->
			classpath proj.value
		}

		classpath MinecraftInstallationToolkit.getLibraries(version)

		workingDir new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "clients/cyan/"+minecraft)

		jvm "-DassetRoot="+MinecraftInstallationToolkit.getAssetsRoot().getCanonicalPath()
		jvm "-DassetIndex="+MinecraftInstallationToolkit.getAssetId(version)
		jvm "-DcyanAgentJar="+project(':Fluid').tasks.jar.archivePath.getCanonicalPath()
		jvm "-Djdk.attach.allowAttachSelf=true"
		jvm "-Dcyancore.resourceloader.rewriteresource.org.asf.cyan.core.CyanInfo.source="+project(":CyanCore").sourceSets.main.output.resourcesDir.getCanonicalPath()
		jvm MinecraftInstallationToolkit.generateJvmArguments(version, null,
				new File[0], MinecraftInstallationToolkit.getNativesDirectory(version), jar, null, false)
		jvm "org.asf.software.sideterminal.SideTermMain"

		Log4jToGradleAppender.noLogInfo()
	}
}

task createDeobfServerLaunch (type: EclipseLaunchGenerator) {
	name "Launch Cyan " + minecraft + " Server (Deobfuscated)"
	jvm "-Dcyan.deobfuscated=true"
	jvm "-Dcyan.side=SERVER"
	doFirst {
		Log4jToGradleAppender.logInfo()
		MinecraftInstallationToolkit.setIDE()

		MinecraftVersionInfo version = MinecraftVersionToolkit.getVersion(minecraft)
		if (MinecraftInstallationToolkit.getVersionJar(version, GameSide.SERVER) == null)
			MinecraftInstallationToolkit.downloadVersionJar(version, GameSide.SERVER)
		if (!MinecraftMappingsToolkit.areMappingsAvailable(version, GameSide.SERVER)) {
			MinecraftMappingsToolkit.downloadVanillaMappings(version, GameSide.SERVER)
			MinecraftMappingsToolkit.saveMappingsToDisk(version, GameSide.SERVER)
		}
		MinecraftMappingsToolkit.loadMappings(version, GameSide.SERVER)

		mainClass "org.asf.software.sideterminal.SideTermMain"
		argument project.group+".CyanIDEWrapper"

		File jar = MinecraftModdingToolkit.deobfuscateJar(version, GameSide.SERVER)
		libsMC.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}
		libsTest.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}
		classpath jar

		project(":").childProjects.each { proj ->
			classpath proj.value
		}

		sourceLookup MinecraftModdingToolkit.sourcesJar(version, GameSide.SERVER)

		workingDir new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft)
		if (!new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft).exists())
			new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft).mkdirs()

		if (!new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft+"/eula.txt").exists())
			Files.writeString(new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft+"/eula.txt").toPath(), "eula=true")

		jvm "-javaagent:"+project(':Fluid').tasks.jar.archivePath.getCanonicalPath()
		jvm "-Dcyancore.resourceloader.rewriteresource.org.asf.cyan.core.CyanInfo.source="+project(":CyanCore").sourceSets.main.output.resourcesDir.getCanonicalPath()
		jvm "org.asf.software.sideterminal.SideTermMain"

		Log4jToGradleAppender.noLogInfo()
	}
}

task createObfusServerLaunch (type: EclipseLaunchGenerator) {
	name "Launch Cyan " + minecraft + " Server (Obfuscated)"
	jvm "-Dcyan.deobfuscated=false"
	jvm "-Dcyan.side=SERVER"
	doFirst {
		Log4jToGradleAppender.logInfo()
		MinecraftInstallationToolkit.setIDE()

		MinecraftVersionInfo version = MinecraftVersionToolkit.getVersion(minecraft)
		if (MinecraftInstallationToolkit.getVersionJar(version, GameSide.SERVER) == null)
			MinecraftInstallationToolkit.downloadVersionJar(version, GameSide.SERVER)

		mainClass "org.asf.software.sideterminal.SideTermMain"
		argument project.group+".CyanIDEWrapper"

		File jar = MinecraftInstallationToolkit.getVersionJar(version, GameSide.SERVER)
		libsMC.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}
		libsTest.forEach { k, v ->
			if (v != null) {
				classpath k, v
			} else {
				classpath k
			}
		}
		classpath jar

		project(":").childProjects.each { proj ->
			classpath proj.value
		}

		workingDir new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft)
		if (!new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft).exists())
			new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft).mkdirs()

		if (!new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft+"/eula.txt").exists())
			Files.writeString(new File(MinecraftInstallationToolkit.getMinecraftDirectory(), "servers/cyan/"+minecraft+"/eula.txt").toPath(), "eula=true")

		jvm "-javaagent:"+project(':Fluid').tasks.jar.archivePath.getCanonicalPath()
		jvm "-Dcyancore.resourceloader.rewriteresource.org.asf.cyan.core.CyanInfo.source="+project(":CyanCore").sourceSets.main.output.resourcesDir.getCanonicalPath()
		jvm "org.asf.software.sideterminal.SideTermMain"

		Log4jToGradleAppender.noLogInfo()
	}
}
createEclipseLaunches.finalizedBy createObfusServerLaunch
createEclipseLaunches.finalizedBy createDeobfServerLaunch
createEclipseLaunches.finalizedBy createObfusLaunch
createEclipseLaunches.finalizedBy createDeobfLaunch

def bootlibs = ["javassist", "reflections"]
def libnames = []
def remotelibs = new HashMap<String, URL>()
def filepaths = new HashMap<String, Path>()

def fabricloader = ""
def fabricintermediary = ""

def loadfirst = ["gson"]
if (!modloader.equals("")) {
	if (modloader.startsWith("forge-")) {
		loadfirst.add("log4j-core")
		loadfirst.add("log4j-api")
	}
}

String cyanclasspath = ""
String bootclasspath = ""

libraries.forEach { k, v ->
	String[] information = k.split(":")
	String group = ""
	String name = information[0]
	String versionstr = ""

	if (information.length == 3) {
		group = information[0]
		name = information[1]
		versionstr = information[2]
	} else if (information.length >= 2) {
		name = information[0]
		versionstr = information[1]
	}

	if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) }) && loadfirst.stream().anyMatch({ t -> t.equalsIgnoreCase(name) })) {
		if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
		libnames.add(group+"."+name)

		def lib = "libraries/"+group.replaceAll("\\.", "/")

		lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
		filepaths.put(lib, v.toPath())

		cyanclasspath += lib
	} else if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) }) && bootlibs.stream().anyMatch({ t -> t.equalsIgnoreCase(name) })) {
		if (!bootclasspath.isEmpty()) bootclasspath+=" "
		libnames.add(group+"."+name)

		def lib = "libraries/"+group.replaceAll("\\.", "/")

		lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
		filepaths.put(lib, v.toPath())

		bootclasspath += lib
	}
}

if (!modloader.equals("")) {
	if (modloader.startsWith("forge-")) {
		def forgeversion = modloader.substring("forge-".length())
		File forgeInstaller = new File(cyanCache, "forge-"+minecraft+"-"+forgeversion+"-installer.jar")
		File serverFolder = new File(cyanCache, "forge-"+minecraft+"-"+forgeversion+"-server")
		if (!serverFolder.exists()) {
			println "Installing forge server for dependencies..."
			javaexec {
				workingDir cyanCache
				classpath files(forgeInstaller)
				args '--installServer', new File(cyanCache, "forge-"+minecraft+"-"+forgeversion+"-server.tmp").getAbsolutePath()
			}
			Files.move(new File(cyanCache, "forge-"+minecraft+"-"+forgeversion+"-server.tmp").toPath(), serverFolder.toPath())
		}
		println "Processing forge server dependencies..."
		HashMap<String, File> filecollection = scanFiles(new File(serverFolder, "libraries"), "libraries/", "jar", "jar.cache")
		filecollection.forEach { str, f ->
			String[] information = str.split("/")
			String group = ""
			String name = ""
			String version = ""

			for (int i = information.length - 2; i >= 1 ; i--) {
				if (version.isEmpty()) version = information[i]
				else if (name.isEmpty()) name = information[i]
				else {
					if (group.isEmpty()) group = information[i]
					else group = information[i] + "." + group
				}
			}

			String groupstr = group.replaceAll("\\.", "/")
			if (!groupstr.isEmpty()) groupstr += "/"
			boolean newer = false
			for (String libfile : filecollection.keySet())  {
				if (libfile.startsWith("libraries/"+groupstr+name+"/")) {
					String newversion = libfile.substring(("libraries/"+groupstr+name+"/").length());
					newversion = newversion.substring(0, newversion.indexOf("/"));
					if (!version.equals(newversion)) {
						newversion = newversion.replaceAll("[^0-9.]", "")
						String oldver = version.replaceAll("[^0-9.]", "")
						int ind = 0
						String[] old = oldver.split("\\.")
						for (String vn : newversion.split("\\.")) {
							if (ind < old.length) {
								String vnold = old[ind]
								if (Integer.valueOf(vn) > Integer.valueOf(vnold)) {
									newer = true
									break
								} else if (Integer.valueOf(vn) < Integer.valueOf(vnold)) {
									break
								}
								ind++;
							} else break
						}
						if (newer) break
					}
				}
			}

			if (!newer) {
				String[] libs = filecollection.keySet().stream().filter({it.startsWith("libraries/"+groupstr+name+"/"+version+"/"+name+"-"+version)}).toArray({new String[it]})

				if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) })) {
					for (String lib : libs)  {
						if (lib.endsWith(".jar")) cyanclasspath += " "+lib
						filepaths.put(lib, filecollection.get(lib).toPath())
					}
					libnames.add(group+"."+name)
				}
			}
		}
	} else if (modloader.startsWith("fabric-loader-")) {
		println "Resolving fabric dependencies..."
		def fabricversion = modloader.substring("fabric-loader-".length())
		URL mdataURL = new URL("https://meta.fabricmc.net/v2/versions/loader/"+minecraft+"/"+fabricversion)
		InputStreamReader rd = new InputStreamReader(mdataURL.openStream())
		JsonElement ele = JsonParser.parseReader(rd)
		JsonObject metadata = (ele.isJsonArray() ? ele.getAsJsonArray().get(0).getAsJsonObject() : ele.getAsJsonObject())
		rd.close()

		for (JsonElement dependency : metadata.get("launcherMeta").getAsJsonObject().get("libraries").getAsJsonObject().get("common").getAsJsonArray()) {
			JsonObject obj = dependency.getAsJsonObject()
			String[] information = obj.get("name").getAsString().split(":")
			String url = obj.get("url").getAsString()

			String group = ""
			String name = information[0]
			String versionstr = ""

			if (information.length == 3) {
				group = information[0]
				name = information[1]
				versionstr = information[2]
			} else if (information.length >= 2) {
				name = information[0]
				versionstr = information[1]
			}

			url = url + "/"+group.replaceAll("\\.", "/")+"/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
			if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) })) {
				if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
				libnames.add(group+"."+name)

				def lib = "libraries/"+group.replaceAll("\\.", "/")

				lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
				remotelibs.put(lib, new URL(url))

				cyanclasspath += lib
			}
		}

		for (JsonElement dependency : metadata.get("launcherMeta").getAsJsonObject().get("libraries").getAsJsonObject().get("server").getAsJsonArray()) {
			JsonObject obj = dependency.getAsJsonObject()
			String[] information = obj.get("name").getAsString().split(":")
			String url = obj.get("url").getAsString()

			String group = ""
			String name = information[0]
			String versionstr = ""

			if (information.length == 3) {
				group = information[0]
				name = information[1]
				versionstr = information[2]
			} else if (information.length >= 2) {
				name = information[0]
				versionstr = information[1]
			}

			url = url + "/"+group.replaceAll("\\.", "/")+"/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
			if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) })) {
				if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
				libnames.add(group+"."+name)

				def lib = "libraries/"+group.replaceAll("\\.", "/")

				lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
				remotelibs.put(lib, new URL(url))

				cyanclasspath += lib
			}
		}

		String[] information = metadata.get("loader").getAsJsonObject().get("maven").getAsString().split(":")
		String url = "https://maven.fabricmc.net/"

		String group = ""
		String name = information[0]
		String versionstr = ""

		if (information.length == 3) {
			group = information[0]
			name = information[1]
			versionstr = information[2]
		} else if (information.length >= 2) {
			name = information[0]
			versionstr = information[1]
		}

		url = url + "/"+group.replaceAll("\\.", "/")+"/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
		if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) })) {
			if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
			libnames.add(group+"."+name)

			def lib = "libraries/"+group.replaceAll("\\.", "/")

			lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
			remotelibs.put(lib, new URL(url))

			cyanclasspath += lib
			fabricloader = lib
		}

		information = metadata.get("intermediary").getAsJsonObject().get("maven").getAsString().split(":")
		url = "https://maven.fabricmc.net/"

		group = ""
		name = information[0]
		versionstr = ""

		if (information.length == 3) {
			group = information[0]
			name = information[1]
			versionstr = information[2]
		} else if (information.length >= 2) {
			name = information[0]
			versionstr = information[1]
		}

		url = url + "/"+group.replaceAll("\\.", "/")+"/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
		if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) })) {
			if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
			libnames.add(group+"."+name)

			def lib = "libraries/"+group.replaceAll("\\.", "/")

			lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
			remotelibs.put(lib, new URL(url))

			fabricintermediary = lib
		}

		println "Done."
	}
}

apply from: '../asf.mvn.publish.gradle'

configurePublish {
	pretty_name "Cyan Launch Wrappers"
	description "Cyan launch wrappers, allows cyan to be launched from the minecraft launcher"
	page "https://aerialworks.ddns.net/maven"
	address "https://aerialworks.ddns.net/maven"

	author {
		name "$authorname"
		id "ASF"
	}

	license {
		name "GNU General Public License v2.0"
		url "https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt"
	}

	artifact {
		name "CyanVersionHolder"
		pretty_artifact_name "Generic Cyan Information Artifact"
		artifact_description "Generic artifact for holding the cyan version information, used for version checking"
		artifact_version "generic"
		artifact_resource "versions.ccfg"
	}

	artifact {
		name "CyanVersionHolder"
		pretty_artifact_name "Generic Cyan Information Artifact"
		artifact_description "Generic artifact for holding the cyan version information, used for version checking"
		artifact_version "${cyanversion}"
		artifact_resource "versions.ccfg"
	}

	resource "version-launcher.json", "${minecraft}-cyan-"+cyanversion+".json"
}

initializeASFMVNPublish()

def msg = "CYAN FOR MINECRAFT VERSION ${minecraft}, CYAN ${cyanversion}"+(modloader.equals("") ? "" : ", MODLOADER: "+modloader)
def msg2 = "Development initiated date: ${timeStartHuman}"
def msg3 = "Release date: ${timeReleaseHuman}"
def msg4 = "Mappings Version: " + mappingsVersion

def l = msg.length()
if (msg2.length() > l)
	l = msg2.length()
if (msg3.length() > l)
	l = msg3.length()
if (msg4.length() > l)
	l = msg4.length()

def bar = "------"
for (int i = 0; i < l; i++)
	bar += "-"

println ""
println bar
println ""
println "   " + msg
println "   " + msg2
println "   " + msg3
println ""
println "   " + msg4
println ""
println bar
println ""

processResources {
	duplicatesStrategy = DuplicatesStrategy.INCLUDE

	def logSha = "Unknown"
	def logSize = "0"
	def useurl = fallback_url
	if (fallback_url.equals(""))
		useurl = netTestUrl

	def url = useurl+"/"+cyanloader_package+"/"+cyanloader_logconf_version+"/CyanLoader-${cyanloader_logconf_version}-log4j2.xml"

	boolean wasLTS = false
	def ltscyanversions=[]
	def unsupportedcyan=[]
	def unsupported = ""
	def lts = ""
	def allcyan = ""
	def allcyanchangelog = ""
	def byGameVersions = ""
	def cyanforgesupportversions = ""
	def cyanfabricsupportversions = ""
	def cyanpapersupportversions = ""

	def paperByMappings = ""
	def spigotStableMappings = ""
	def spigotLatestMappings = ""
	def spigotTestingMappings = ""
	
	def yarnMappings = ""
	def spigotMappings = ""

	def lateststable = ""
	def latestalpha = ""
	def latestbeta = ""
	def latestpreview = ""

	def libraryVersions = ""

	HashMap<String, String> libraryVersionMap = new HashMap<String, String>();
	HashMap<String, String> gameVersions = new HashMap<String, String>();
	HashMap<String, String> forgeSupportVersions = new HashMap<String, String>();
	HashMap<String, String> fabricSupportVersions = new HashMap<String, String>();
	HashMap<String, String> paperSupportVersions = new HashMap<String, String>();

	HashMap<String, String> paperMappingVersions = new HashMap<String, String>();

	HashMap<String, String> stableSpigotMappings = new HashMap<String, String>();
	HashMap<String, String> latestSpigotMappings = new HashMap<String, String>();
	HashMap<String, String> testingSpigotMappings = new HashMap<String, String>();
	
	HashMap<String, String> yarnMappingVersions = new HashMap<String, String>();
	HashMap<String, String> spigotMappingVersions = new HashMap<String, String>();

	try {
		StringBuilder conf = new StringBuilder();
		URL u = new URL(useurl + infoPath);
		Scanner sc = new Scanner(u.openStream());
		while (sc.hasNext())
			conf.append(sc.nextLine()+System.lineSeparator());
		sc.close();

		CyanUpdateInfo info = new CyanUpdateInfo(conf.toString())
		lateststable = info.latestStableVersion
		latestalpha = info.latestAlphaVersion
		latestbeta = info.latestBetaVersion
		latestpreview = info.latestPreviewVersion

		for (String key : info.allVersions.keySet()) {
			def val = info.allVersions.get(key)
			if (!cyanversion.toString().equals(key)) {
				allcyan += "    $key> '${val}'\n"
			}
		}

		for (String key : info.changelogs.keySet()) {
			def val = info.changelogs.get(key).replaceAll("\n", "\n    ")
			if (!cyanversion.toString().equals(key)) {
				allcyanchangelog += "    $key> '${val}'\n"
			}
		}

		for (String key : info.byGameVersions.keySet()) {
			def val = info.byGameVersions.get(key).replaceAll("\n", "\n    ")
			gameVersions.put(key, val)
		}

		for (String key : info.forgeSupport.keySet()) {
			def val = info.forgeSupport.get(key).replaceAll("\n", "\n    ")
			forgeSupportVersions.put(key, val)
		}

		for (String key : info.fabricSupport.keySet()) {
			def val = info.fabricSupport.get(key).replaceAll("\n", "\n    ")
			fabricSupportVersions.put(key, val)
		}

		for (String key : info.paperSupport.keySet()) {
			def val = info.paperSupport.get(key).replaceAll("\n", "\n    ")
			paperSupportVersions.put(key, val)
		}

		for (def ltsver : info.longTermSupportVersions) {
			if (ltsver.equals(cyanversion)) {
				wasLTS = true
				continue;
			}
			ltscyanversions.add(ltsver)
		}

		for (def unsupportedver : info.requiredUpgrade) {
			if (unsupportedver.equals(cyanversion)) continue
				unsupportedcyan.add(unsupportedver)
		}

		for (def ver : info.paperByMappings.keySet()) {
			def val = info.paperByMappings.get(ver)

			if (project.hasProperty("removePaper") && project.getProperty("removePaper").equals(val))
				continue;

			paperMappingVersions.put(ver, val)
		}

		for (def ver : info.spigotStableMappings.keySet()) {
			def val = info.spigotStableMappings.get(ver)
			stableSpigotMappings.put(ver, val)
		}

		for (def ver : info.spigotLatestMappings.keySet()) {
			def val = info.spigotLatestMappings.get(ver)
			latestSpigotMappings.put(ver, val)
		}

		for (def ver : info.spigotTestingMappings.keySet()) {
			def val = info.spigotTestingMappings.get(ver)
			testingSpigotMappings.put(ver, val)
		}
		
		for (def ver : info.yarnMappings.keySet()) {
			def val = info.yarnMappings.get(ver)
			yarnMappingVersions.put(ver, val)
		}
		
		for (def ver : info.spigotMappings.keySet()) {
			def val = info.spigotMappings.get(ver)
			spigotMappingVersions.put(ver, val)
		}

		for (def ver : info.libraryVersions.keySet()) {
			if (ver.startsWith("ModKit-")) {
				libraryVersionMap.put(ver, info.libraryVersions.get(ver))
			}
		}
	} catch (IOException e) {
		logger.warn("WARNING: Failed to download update information file from: "+useurl + infoPath)
		logger.warn("You will be missing CYAN version information entries!")
	}

	def loaderversion = null;
	if (!modloader.equals("")) {
		if (modloader.startsWith("forge-")) {
			loaderversion = modloader.substring("forge-".length())
		} else if (modloader.startsWith("fabric-loader-")) {
			loaderversion = modloader.substring("fabric-loader-".length())
		}  else if (modloader.startsWith("paper-")) {
			loaderversion = modloader.substring("paper-".length())
		}
	}

	if (project.hasProperty("removeLTSVersions")) {
		for (String ltsver : project.getProperty("removeLTSVersions").split(" ")) {
			def ltsid = "lts-" + ltsver
			def ltsgameversions = new ArrayList<String>()

			for (String key : new ArrayList<String>(gameVersions.keySet())) {
				String val = gameVersions.get(key)
				if (val.equals(ltsver) && key.endsWith("-" + ltsid)) {
					gameVersions.remove(key)
					ltsgameversions.add(key)
				}
			}

			for (String key : paperSupportVersions.keySet()) {
				String val = paperSupportVersions.get(key)
				if (val.equals(ltsver) && (key.endsWith("-" + ltsid) || key.startsWith(ltsid + "-"))) {
					paperSupportVersions.remove(key)
					break
				}
			}
			for (String key : forgeSupportVersions.keySet()) {
				String val = forgeSupportVersions.get(key)
				if (val.equals(ltsver) && key.endsWith("-" + ltsid) || key.startsWith(ltsid + "-")) {
					forgeSupportVersions.remove(key)
					break
				}
			}
			for (String key : fabricSupportVersions.keySet()) {
				String val = fabricSupportVersions.get(key)
				if (val.equals(ltsver) && key.endsWith("-" + ltsid) || key.startsWith(ltsid + "-")) {
					fabricSupportVersions.remove(key)
					break
				}
			}
			for (String key : paperSupportVersions.keySet()) {
				String val = paperSupportVersions.get(key)
				if (val.equals(ltsver) && key.endsWith("-" + ltsid) || key.startsWith(ltsid + "-")) {
					paperSupportVersions.remove(key)
					break
				}
			}
		}
	}

	if (project.hasProperty("removeFromLatest")) {
		for (String key : gameVersions.keySet()) {
			String val = gameVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-latest")) {
				gameVersions.remove(key)
				break
			}
		}
		for (String key : paperSupportVersions.keySet()) {
			String val = paperSupportVersions.get(key)
			if (val.equals(cyanversion) && (key.endsWith("-latest") || key.startsWith("latest-paper-") || key.equals("latest-paper"))) {
				paperSupportVersions.remove(key)
				break
			}
		}
		for (String key : forgeSupportVersions.keySet()) {
			String val = forgeSupportVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-latest") || key.startsWith("latest-forge-") || key.equals("latest-forge")) {
				forgeSupportVersions.remove(key)
				break
			}
		}
		for (String key : fabricSupportVersions.keySet()) {
			String val = fabricSupportVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-latest") || key.startsWith("latest-fabric-") || key.equals("latest-fabric")) {
				fabricSupportVersions.remove(key)
				break
			}
		}

		if (latestSpigotMappings.containsKey(minecraft)) {
			latestSpigotMappings.remove(minecraft)
		}
	}

	if (project.hasProperty("removeFromStable")) {
		for (String key : gameVersions.keySet()) {
			String val = gameVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-stable")) {
				gameVersions.remove(key)
				break
			}
		}
		for (String key : paperSupportVersions.keySet()) {
			String val = paperSupportVersions.get(key)
			if (val.equals(cyanversion) && (key.endsWith("-stable") || key.startsWith("stable-paper-") || key.equals("stable-paper"))) {
				paperSupportVersions.remove(key)
				break
			}
		}
		for (String key : forgeSupportVersions.keySet()) {
			String val = forgeSupportVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-stable") || key.startsWith("stable-forge-") || key.equals("stable-forge")) {
				forgeSupportVersions.remove(key)
				break
			}
		}
		for (String key : fabricSupportVersions.keySet()) {
			String val = fabricSupportVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-stable") || key.startsWith("stable-fabric-") || key.equals("stable-fabric")) {
				fabricSupportVersions.remove(key)
				break
			}
		}

		if (stableSpigotMappings.containsKey(minecraft)) {
			stableSpigotMappings.remove(minecraft)
		}
	}

	if (project.hasProperty("removeFromTesting")) {
		for (String key : gameVersions.keySet()) {
			String val = gameVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-testing")) {
				gameVersions.remove(key)
				break
			}
		}
		for (String key : paperSupportVersions.keySet()) {
			String val = paperSupportVersions.get(key)
			if (val.equals(cyanversion) && (key.endsWith("-testing") || key.startsWith("testing-paper-") || key.equals("testing-paper"))) {
				paperSupportVersions.remove(key)
				break
			}
		}
		for (String key : forgeSupportVersions.keySet()) {
			String val = forgeSupportVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-testing") || key.startsWith("testing-forge-") || key.equals("testing-forge")) {
				forgeSupportVersions.remove(key)
				break
			}
		}
		for (String key : fabricSupportVersions.keySet()) {
			String val = fabricSupportVersions.get(key)
			if (val.equals(cyanversion) && key.endsWith("-testing") || key.startsWith("testing-fabric-") || key.equals("testing-fabric")) {
				fabricSupportVersions.remove(key)
				break
			}
		}

		for (String ver : testingSpigotMappings.keySet()) {
			String val = testingSpigotMappings.get(ver)
			if (val.equals(minecraft)) {
				testingSpigotMappings.remove(ver)
				break
			}
		}

		if (testingSpigotMappings.containsKey(minecraft)) {
			testingSpigotMappings.remove(minecraft)
		}
	} else {
		gameVersions.put(minecraft + "-testing", cyanversion)

		if (!modloader.equals("")) {
			if (modloader.startsWith("forge-")) {
				forgeSupportVersions.put("testing-forge", minecraft + "-" + loaderversion)
				forgeSupportVersions.put("testing-forge-" + minecraft, loaderversion)
				forgeSupportVersions.put("testing-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				forgeSupportVersions.put(minecraft + "-" + loaderversion + "-testing", cyanversion);
			} else if (modloader.startsWith("fabric-loader-")) {
				fabricSupportVersions.put("testing-fabric", minecraft + "-" + loaderversion)
				fabricSupportVersions.put("testing-fabric-" + minecraft, loaderversion)
				fabricSupportVersions.put("testing-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				fabricSupportVersions.put(minecraft + "-" + loaderversion + "-testing", cyanversion);
			} else if (modloader.startsWith("paper-")) {
				paperSupportVersions.put("testing-paper", minecraft + "-" + loaderversion)
				paperSupportVersions.put("testing-paper-" + minecraft, loaderversion)
				paperSupportVersions.put("testing-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				paperSupportVersions.put(minecraft + "-" + loaderversion + "-testing", cyanversion);

				testingSpigotMappings.put(minecraft, mappingsVersion)
			}
		}
	}

	if (modloader.startsWith("paper-") && (!project.hasProperty("removePaper") || !project.getProperty("removePaper").equals(loaderversion))) {
		paperMappingVersions.put(mappingsVersion, loaderversion)
		spigotMappingVersions.put("paper-" + minecraft + "-" + loaderversion, mappingsVersion)
		spigotMappingVersions.put("cyan-" + minecraft + "-" + cyanversion, mappingsVersion)
	}

	if (project.hasProperty("addToLatest")) {
		gameVersions.put(minecraft + "-latest", cyanversion)

		if (!modloader.equals("")) {
			if (modloader.startsWith("forge-")) {
				forgeSupportVersions.put("latest-paper", minecraft + "-" + loaderversion)
				forgeSupportVersions.put("latest-paper-" + minecraft, loaderversion)
				forgeSupportVersions.put("latest-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				forgeSupportVersions.put(minecraft + "-" + loaderversion + "-latest", cyanversion);
			} else if (modloader.startsWith("fabric-loader-")) {
				fabricSupportVersions.put("latest-fabric", minecraft + "-" + loaderversion)
				fabricSupportVersions.put("latest-fabric-" + minecraft, loaderversion)
				fabricSupportVersions.put("latest-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				fabricSupportVersions.put(minecraft + "-" + loaderversion + "-latest", cyanversion);
			}  else if (modloader.startsWith("paper-")) {
				paperSupportVersions.put("latest-paper", minecraft + "-" + loaderversion)
				paperSupportVersions.put("latest-paper-" + minecraft, loaderversion)
				paperSupportVersions.put("latest-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				paperSupportVersions.put(minecraft + "-" + loaderversion + "-latest", cyanversion);

				testingSpigotMappings.put(minecraft, mappingsVersion)
				latestSpigotMappings.put(minecraft, mappingsVersion)
			}
		}
	} else if (project.hasProperty("addToStable") || (project.hasProperty("LTS") && project.getProperty("LTS").equals("true"))) {
		gameVersions.put(minecraft + "-stable", cyanversion)
		gameVersions.put(minecraft + "-latest", cyanversion)

		if (!modloader.equals("")) {
			if (modloader.startsWith("forge-")) {
				forgeSupportVersions.put("stable-forge", minecraft + "-" + loaderversion)
				forgeSupportVersions.put("latest-forge", minecraft + "-" + loaderversion)
				forgeSupportVersions.put("stable-forge-" + minecraft, loaderversion)
				forgeSupportVersions.put("stable-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				forgeSupportVersions.put("latest-forge-" + minecraft, loaderversion)
				forgeSupportVersions.put("latest-cyan-" + minecraft + "-" + cyanversion, loaderversion)

				forgeSupportVersions.put(minecraft + "-" + loaderversion + "-latest", cyanversion);
				forgeSupportVersions.put(minecraft + "-" + loaderversion + "-stable", cyanversion);
			} else if (modloader.startsWith("fabric-loader-")) {
				fabricSupportVersions.put("stable-fabric", minecraft + "-" + loaderversion)
				fabricSupportVersions.put("latest-fabric", minecraft + "-" + loaderversion)
				fabricSupportVersions.put("stable-fabric-" + minecraft, loaderversion)
				fabricSupportVersions.put("stable-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				fabricSupportVersions.put("latest-fabric-" + minecraft, loaderversion)
				fabricSupportVersions.put("latest-cyan-" + minecraft + "-" + cyanversion, loaderversion)

				fabricSupportVersions.put(minecraft + "-" + loaderversion + "-latest", cyanversion);
				fabricSupportVersions.put(minecraft + "-" + loaderversion + "-stable", cyanversion);
			}  else if (modloader.startsWith("paper-")) {
				paperSupportVersions.put("stable-paper", minecraft + "-" + loaderversion)
				paperSupportVersions.put("latest-paper", minecraft + "-" + loaderversion)
				paperSupportVersions.put("stable-paper-" + minecraft, loaderversion)
				paperSupportVersions.put("stable-cyan-" + minecraft + "-" + cyanversion, loaderversion)
				paperSupportVersions.put("latest-paper-" + minecraft, loaderversion)
				paperSupportVersions.put("latest-cyan-" + minecraft + "-" + cyanversion, loaderversion)

				paperSupportVersions.put(minecraft + "-" + loaderversion + "-latest", cyanversion);
				paperSupportVersions.put(minecraft + "-" + loaderversion + "-stable", cyanversion);

				testingSpigotMappings.put(minecraft, mappingsVersion)
				latestSpigotMappings.put(minecraft, mappingsVersion)
				stableSpigotMappings.put(minecraft, mappingsVersion)
			}
		}

		if (project.hasProperty("LTS") && project.getProperty("LTS").equals("true")) {
			gameVersions.put(minecraft + "-lts-" + cyanversion, cyanversion)

			if (modloader.startsWith("forge-")) {
				forgeSupportVersions.put("lts-"+cyanversion+"-forge-" + minecraft, loaderversion);
				forgeSupportVersions.put(minecraft + "-" + loaderversion + "-lts-"+cyanversion, cyanversion);
			} else if (modloader.startsWith("fabric-loader-")) {
				fabricSupportVersions.put("lts-"+cyanversion+"-fabric-" + minecraft, loaderversion);
				fabricSupportVersions.put(minecraft + "-" + loaderversion + "-lts-"+cyanversion, cyanversion);
			}  else if (modloader.startsWith("paper-")) {
				paperSupportVersions.put("lts-"+cyanversion+"-paper-" + minecraft, loaderversion);
				paperSupportVersions.put(minecraft + "-" + loaderversion + "-lts-"+cyanversion, cyanversion);

				testingSpigotMappings.put(minecraft, mappingsVersion)
				latestSpigotMappings.put(minecraft, mappingsVersion)
				stableSpigotMappings.put(minecraft, mappingsVersion)
			}
		}
	}

	def apiID1 = null
	def apiID2 = null
	libraries.each { k, v ->
		def name = null
		def version = null
		project(":").childProjects.each { proj ->
			if (k.equals(proj.value.group+":"+proj.value.name+":"+proj.value.version) && proj.value.file('bin/main').exists() && proj.value.hasProperty("sourceSets")) {
				name = proj.value.name
				version = proj.value.version
			}
		}

		if (name != null) {
			libraryVersionMap.put(name, version)
		}
	}

	for (String key : gameVersions.keySet()) {
		def val = gameVersions.get(key).replaceAll("\n", "\n    ")
		byGameVersions += "    $key> '${val}'\n"
	}

	for (String key : forgeSupportVersions.keySet()) {
		def val = forgeSupportVersions.get(key).replaceAll("\n", "\n    ")
		cyanforgesupportversions += "    $key> '${val}'\n"
	}

	for (String key : fabricSupportVersions.keySet()) {
		def val = fabricSupportVersions.get(key).replaceAll("\n", "\n    ")
		cyanfabricsupportversions += "    $key> '${val}'\n"
	}

	for (String key : paperSupportVersions.keySet()) {
		def val = paperSupportVersions.get(key).replaceAll("\n", "\n    ")
		cyanpapersupportversions += "    $key> '${val}'\n"
	}

	for (String key : testingSpigotMappings.keySet()) {
		def val = testingSpigotMappings.get(key).replaceAll("\n", "\n    ")
		spigotTestingMappings += "    $key> '${val}'\n"
	}

	for (String key : latestSpigotMappings.keySet()) {
		def val = latestSpigotMappings.get(key).replaceAll("\n", "\n    ")
		spigotLatestMappings += "    $key> '${val}'\n"
	}

	for (String key : stableSpigotMappings.keySet()) {
		def val = stableSpigotMappings.get(key).replaceAll("\n", "\n    ")
		spigotStableMappings += "    $key> '${val}'\n"
	}

	for (String key : paperMappingVersions.keySet()) {
		def val = paperMappingVersions.get(key).replaceAll("\n", "\n    ")
		paperByMappings += "    $key> '${val}'\n"
	}

	if ((project.hasProperty("LTS") && project.getProperty("LTS").equals("true")) || (wasLTS && (!project.hasProperty("LTS") || project.getProperty("LTS").equals("true")))) {
		ltscyanversions.add(cyanversion)
	}
	
	if (modloader.startsWith("fabric-loader-")) {
		yarnMappingVersions.put("fabric-"+minecraft+"-"+modloader.substring("fabric-loader-".length()), mappingsVersion)
		yarnMappingVersions.put("cyan-"+minecraft+"-"+cyanversion, mappingsVersion)
	}

	for (String key : yarnMappingVersions.keySet()) {
		def val = yarnMappingVersions.get(key).replaceAll("\n", "\n    ")
		yarnMappings += "    $key> '${val}'\n"
	}

	for (String key : spigotMappingVersions.keySet()) {
		def val = spigotMappingVersions.get(key).replaceAll("\n", "\n    ")
		spigotMappings += "    $key> '${val}'\n"
	}

	if (project.hasProperty("addUnsupportedVersions")) {
		for (String unsupportedver : project.getProperty("addUnsupportedVersions").split(" ")) {
			unsupportedcyan.add(unsupportedver)
			if (ltscyanversions.contains(unsupportedver))
				ltscyanversions.remove(unsupportedver)
		}
	}

	if (project.hasProperty("removeLTSVersions")) {
		for (String ltsver : project.getProperty("removeLTSVersions").split(" ")) {
			if (ltscyanversions.contains(ltsver))
				ltscyanversions.remove(ltsver)
		}
	}

	if (project.hasProperty("addChangeLog")) {
		def value = ""
		def data = project.getProperty("addChangeLog").replace("\r", "").replace("\\n", "\n")
		for (String line : data.split("\n")) {
			if (!value.equals("")) value += "\n    "
			value += line
		}
		allcyanchangelog += "    ${cyanversion}> '${value}'"
	} else if (!allcyanchangelog.equals("")) allcyanchangelog = allcyanchangelog.substring(0, allcyanchangelog.length() - 1)

	for (def version : unsupportedcyan) {
		unsupported += "'"+version+"' "
	}

	for (def version : ltscyanversions) {
		lts += "'"+version+"' "
	}

	def cyantype = ""
	if (cyanversion.contains(".A")) {
		cyantype = "ALPHA"
		latestalpha = cyanversion
	}
	if (cyanversion.contains(".B")) {
		cyantype = "BETA"
		latestbeta = cyanversion
		latestalpha = cyanversion
	}
	if (cyanversion.contains(".P") || project.hasProperty("addToLatest")) {
		if (cyanversion.contains(".P"))
			cyantype = "PREVIEW"
			
		latestpreview = cyanversion
		latestbeta = cyanversion
		latestalpha = cyanversion
	}
	if (cyanversion.contains(".R") || project.hasProperty("addToStable") || (project.hasProperty("LTS") && project.getProperty("LTS"))) {
		if (cyanversion.contains(".R"))
			cyantype = "RELEASE"
		
		lateststable = cyanversion
		latestpreview = cyanversion
		latestbeta = cyanversion
		latestalpha = cyanversion
	}

	allcyan += "    ${cyanversion}> '${cyantype}'"

	inputs.property "paperByMappings", "${paperByMappings}"
	inputs.property "spigotStableMappings", "${spigotStableMappings}"
	inputs.property "spigotTestingMappings", "${spigotTestingMappings}"
	inputs.property "spigotLatestMappings", "${spigotLatestMappings}"
	inputs.property "libraryVersions", "${libraryVersions}"
	inputs.property "mcver", "${minecraft}"
	inputs.property "allcyan", "${allcyan}"
	inputs.property "gameexact", "${exactgameversion}"
	inputs.property "logurl", "${url}"
	inputs.property "modloader", "${modloader}"
	inputs.property "cyanver", cyanversion
	inputs.property "timeStartDev", "${timeStartDev}"
	inputs.property "type", "${versionType}"
	inputs.property "group", project.group
	inputs.property "root", project.file(".").getPath()
	inputs.property "classwrapperclient", "${classWrapperClient}"
	inputs.property "minmixin", "${minmixin}"
	inputs.property "lts", "${lts}"
	inputs.property "allcyanchangelog", "${allcyanchangelog}"
	inputs.property "agentjar", project(':Fluid').tasks.jar.archivePath.getCanonicalPath()
	inputs.property "byGameVersions", "${byGameVersions}"
	inputs.property "cyanforgesupportversions", "${cyanforgesupportversions}"
	inputs.property "cyanfabricsupportversions", "${cyanfabricsupportversions}"
	inputs.property "cyanpapersupportversions", "${cyanpapersupportversions}"
	inputs.property "yarnMappings", "${yarnMappings}"
	inputs.property "spigotMappings", "${spigotMappings}"

	project(":CyanAPI").afterEvaluate {
		libraryVersionMap.put("ModKit-" + modkit, project(":CyanAPI").version);
		
		for (String key : libraryVersionMap.keySet()) {
			def val = libraryVersionMap.get(key).replaceAll("\n", "\n    ")
			libraryVersions += "    $key> '${val}'\n"
		}

        File logShaFile = new File(cyanCache, "logsha.info")
        File logSizeFile = new File(cyanCache, "logsize.info")
        if (!project.hasProperty("noDownload") && !project.hasProperty("currentXML")) {
            if (getServerConnection()) {
                println "Downloading CyanLoader logging context..."
                URL xml = new URL(url)
                URL sha = new URL(url+".sha1")

                BufferedInputStream strm = new BufferedInputStream(xml.openStream())
                logSize = strm.readAllBytes().length.toString()

                Scanner scanner = new Scanner(sha.openStream())
                StringBuilder builder = new StringBuilder()
                while (scanner.hasNext())
                    builder.append(scanner.next())

                logSha = builder.toString()
                scanner.close()
                builder = null

                println "Saving information to cache..."
                Files.writeString(logShaFile.toPath(), logSha)
                Files.writeString(logSizeFile.toPath(), logSize)
            } else {
                if (logShaFile.exists() && logSizeFile.exists() ) {
                    logSha = Files.readString(logShaFile.toPath())
                    logSize = Files.readString(logSizeFile.toPath())
                } else {
                    throw new IOException("No connection to the fallback url, cannot download logging information, it is not stored in cache either!")
                }
            }
        } else if (project.hasProperty("currentXML")) {
            println "Using local file for log sha1 and size properties"
            File xml = new File(project(":CyanLoader").sourceSets.main.output.resourcesDir, "log4j2.xml")
            if (!xml.exists()) {
                logger.error ""
                logger.error "CyanLoader has not yet created its resources, cannot parse sha and size, please rerun the build after it has completed"
                logger.error ""
                return
            }
            logSize = xml.length()
            logSha = calcSha1(xml)
        }

        println ""
        println "Logging file size: "+logSize
        println "Logging file SHA1: "+logSha
        println ""
	
		def projbins = ""
		def resources = ""
		def libs="["+System.lineSeparator()

		if (!modloader.startsWith("paper-")) {
			def apiJarTask = project(":CyanAPI").tasks.getByName("platformRiftJarClient")
			apiID1 = "org.asf.cyan:CyanAPI-RIFT-CLIENT:" + project(":CyanAPI").version + "-" + apiJarTask.getArchiveClassifier().get()
			libraries.put(apiID1, apiJarTask.getArchiveFile().get().getAsFile());
			librarysources.put(apiID1, fallback_url)
			
			apiJarTask = project(":ModKit").tasks.getByName("platformRiftJarClient")
			apiID2 = "org.asf.cyan:ModKit-RIFT-CLIENT:" + project(":ModKit").version + "-" + apiJarTask.getArchiveClassifier().get()
			libraries.put(apiID2, apiJarTask.getArchiveFile().get().getAsFile());
			librarysources.put(apiID2, fallback_url)
		}

		libraries.each { k, v ->
			if (libs.equals("["+System.lineSeparator()))
				libs += template.replaceAll("\\%lib\\%", k).replaceAll("\\%url\\%", librarysources.get(k))
			else
				libs += ","+System.lineSeparator()+template.replaceAll("\\%lib\\%", k).replaceAll("\\%url\\%", librarysources.get(k))
		}
		libs+=System.lineSeparator()+"\t],"

		def libsNoSelf = "["+System.lineSeparator()
		libraries.each { k, v ->
			def add = true
			project(":").childProjects.each { proj ->
				if (k.equals(proj.value.group+":"+proj.value.name+":"+proj.value.version) && proj.value.file('bin/main').exists() && proj.value.hasProperty("sourceSets")) {
					add = false
				}
			}

			if (add) {
				if (libsNoSelf.equals("["+System.lineSeparator()))
					libsNoSelf += template.replaceAll("\\%lib\\%", k).replaceAll("\\%url\\%", librarysources.get(k))
				else
					libsNoSelf += ","+System.lineSeparator()+template.replaceAll("\\%lib\\%", k).replaceAll("\\%url\\%", librarysources.get(k))
			}
		}

		libraries.each { k, v ->
			for (def proj : project(":").childProjects) {
				if (k.equals(proj.value.group+":"+proj.value.name+":"+proj.value.version) && proj.value.file('bin/main').exists()) {
					if (projbins.isEmpty()) projbins=proj.value.file('bin/main').getCanonicalPath();
					else projbins += ":"+proj.value.file('bin/main').getCanonicalPath();

					if (!proj.value.hasProperty("sourceSets")) continue;
					if (resources.isEmpty()) resources = proj.value.sourceSets.main.output.resourcesDir.getCanonicalPath();
					else resources += ":" + proj.value.sourceSets.main.output.resourcesDir.getCanonicalPath();
				}
			}
		}

		libsNoSelf+=System.lineSeparator()+"\t],"
		def props = [
			"mcver": "${minecraft}",
			"gameexact": "${exactgameversion}",
			"modloader": "${modloader}",
			"minmixin": "${minmixin}",
			"cyanver": cyanversion,
			"timeStartDev": "${timeStartDev}",
			"timeRelease": "${timeRelease}",
			"type": "${versionType}",
			"logsha": "${logSha}",
			"logsize": "${logSize}",
			"logurl": "${url}",
			"group": project.group,
			"projname": project.name,
			"projbins": "${projbins}",
			"root": project.file(".").getCanonicalPath(),
			"agentjar": project(':Fluid').tasks.jar.archivePath.getCanonicalPath(),
			"resources": "${resources}",
			"libraries": "${libs}",
			"cyantype": "${cyantype}",
			"lts": "${lts}",
			"allcyan": "${allcyan}",
			"lateststable": "${lateststable}",
			"latestpreview": "${latestpreview}",
			"latestbeta": "${latestbeta}",
			"latestalpha": "${latestalpha}",
			"unsupportedcyan": "${unsupported}",
			"librariesRemSelf": "${libsNoSelf}",
			"groupslashed": project.group.replaceAll("\\.", "/"),
			"classwrapperclient": "${classWrapperClient}",
			"allcyanchangelog": "${allcyanchangelog}",
			"mappingsVersion": "${mappingsVersion}",
			"cyangameversions": "${byGameVersions}",
			"cyanforgesupportversions": "${cyanforgesupportversions}",
			"cyanfabricsupportversions": "${cyanfabricsupportversions}",
			"cyanpapersupportversions": "${cyanpapersupportversions}",
			"libraryVersions": "${libraryVersions}",
			"paperByMappings": "${paperByMappings}",
			"spigotStableMappings": "${spigotStableMappings}",
			"spigotLatestMappings": "${spigotLatestMappings}",
			"spigotTestingMappings": "${spigotTestingMappings}",
			"yarnMappings": "${yarnMappings}",
			"spigotMappings": "${spigotMappings}"
		]

		for (def proj : project(":").childProjects) {
			if (!proj.value.hasProperty("sourceSets")) continue;
			props.put(proj.value.name, [
				"resources": proj.value.sourceSets.main.output.resourcesDir.getCanonicalPath(),
				"name": proj.value.name,
				"version": proj.value.version
			])
		}

		from(sourceSets.main.resources.srcDirs) {
			expand(props)
		}

		if (apiID1 != null)
			libraries.remove(apiID1)
		if (apiID2 != null)
			libraries.remove(apiID2)
	}
}

def versionFiles = [
	("${exactgameversion}-cyan-"+cyanversion+".json"): new File(sourceSets.main.output.resourcesDir, "version-launcher.json")
]

def versionFilesDbg = [
	("${exactgameversion}-cyan-"+cyanversion+"-dbg.json"): new File(sourceSets.main.output.resourcesDir, "version-dbg.json")
]

task gameData () {
	def apiID1 = ""
	def apiID2 = ""
	doLast {
		def apiJarTask = tasks.getByPath(":CyanAPI:platformRiftJarClient")
		apiID1 = "org.asf.cyan:CyanAPI-RIFT-CLIENT:" + project(":CyanAPI").version + "-" + apiJarTask.getArchiveClassifier().get()
		libraries.put(apiID1, apiJarTask.archivePath);
		
		apiJarTask = tasks.getByPath(":ModKit:platformRiftJarClient")
		apiID2 = "org.asf.cyan:ModKit-RIFT-CLIENT:" + project(":ModKit").version + "-" + apiJarTask.getArchiveClassifier().get()
		libraries.put(apiID2, apiJarTask.archivePath);
		
		println "Generating client folders..."
		
		def versions = new File("${buildDir}", project.version+"/.minecraft/versions/${exactgameversion}-cyan-"+cyanversion)
		versions.mkdirs()
		def libs = new File("${buildDir}", project.version+"/.minecraft/libraries/")
		libs.mkdirs()

		println " | Installing library files..."
		libraries.forEach { k, v ->
			def information = k.split(":")
			def group = ""
			def name = information[0]
			def version = ""

			if (information.length == 3) {
				group = information[0]
				name = information[1]
				version = information[2]
			} else if (information.length >= 2) {
				name = information[0]
				version = information[1]
			}

			def dest = new File(libs, group.replaceAll("\\.", "/")+"/"+name+"/"+version)
			dest.mkdirs()
			
			File output = new File(dest, name + "-" + version + ".jar")
			if (output.exists())
				output.delete();
			
			println " +-- Installing library: " + k + ", file: " + output.getName() + "..."
			Files.copy(v.toPath(), output.toPath());
		}
		if (project.hasProperty("currentXML")) {
			def log = new File("${buildDir}", project.version+"/.minecraft/assets/log_configs/")
			log.mkdirs()
			println " |"
			println " | Installing logging files..."
			File xml = new File(project(":CyanLoader").sourceSets.main.output.resourcesDir, "log4j2.xml")
			if (!xml.exists()) {
				logger.error ""
				logger.error "CyanLoader has not yet created its resources, cannot parse sha and size, please rerun the build after it has completed"
				logger.error ""
			} else {
				if (new File(log, "cyanclient-" + cyanversion + ".xml").exists())
					new File(log, "cyanclient-" + cyanversion + ".xml").delete();

				Files.copy(xml.toPath(), new File(log, "cyanclient-" + cyanversion + ".xml").toPath())
			}
		}
		println " |"
		println " | Installing version files..."
		versionFiles.forEach { k, v ->
			println " +-- Installing into: "+k+", file: "+v.name+"..."
			copy {
				from v.getParent()
				into versions
				include v.getName()
				rename v.getName(), k
			}
		}
		println " | Installing debug version files..."
		versions = new File("${buildDir}", project.version+"/.minecraft/versions/${exactgameversion}-cyan-"+cyanversion+"-dbg")
		versions.mkdirs()
		versionFilesDbg.forEach { k, v ->
			println " +-- Installing into: "+k+", file: "+v.name+"..."
			copy {
				from v.getParent()
				into versions
				include v.getName()
				rename v.getName(), k
			}
		}
		libraries.remove(apiID1)
		libraries.remove(apiID2)
	}
}
gameData.dependsOn processResources

task mixinVersion {
	doLast {
		System.setProperty("mixinversion", mixinversion)
	}
}

HashMap<String, File> scanFiles(File inp, String start, String... extensions) {
	HashMap<String, File> collection = new HashMap<String, File>()
	for (File f : inp.listFiles(new FileFilter() {
				@Override
				public boolean accept(File f2) {
					for (String extension : extensions) {
						if (f2.getName().endsWith("."+extension)) return true
					}
					return false
				}
			})) {
		collection.put(start+f.getName(), f)
	}
	for (File f : inp.listFiles(new FileFilter() {
				@Override
				public boolean accept(File f2) {
					return f2.isDirectory()
				}
			})) {
		scanFiles(f, start+f.getName()+"/", extensions).forEach { p, f2 ->
			collection.put(p, f2)
		}
	}
	return collection
}

task serverJar (type: Jar, dependsOn: build) {
	def dest = null
	def apiID1 = null
	def apiID2 = null

	dest = file('../build/Wrapper/Server jars/'+cyanversion+"-mc-"+exactgameversion)
	if (!dest.exists())
		dest.mkdirs();

	destinationDirectory = dest
	archiveClassifier = 'server'
	archiveVersion = exactgameversion+"-cyan-"+cyanversion
	archiveBaseName = 'minecraft'

	exclude "**/extra/**"
	exclude "**/tests/**"
	exclude "version-launcher.json"
	exclude "version-dbg.json"
	
	includeEmptyDirs = false
	outputs.upToDateWhen { return false; }
	
	if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
	
	if (!modloader.isEmpty() && modloader.startsWith("paper-")) {
		def paperversion = modloader.substring("paper-".length())
		if (!cyanclasspath.isEmpty()) cyanclasspath+=" "
		cyanclasspath+="paper-server-${paperversion}.jar"
		cyanclasspath+=" cache/patched_${minecraft}.jar"
	} else {
		cyanclasspath+="vanilla-server.jar"
  	}


	from sourceSets.main.output
	libnames.add(project.group+"."+project.name)
	
	from project(":Fluid").sourceSets.main.output
	libnames.add(project(":Fluid").group+"."+project(":Fluid").name)
	
	from project(":CyanCore").sourceSets.main.output
	libnames.add(project(":CyanCore").group+"."+project(":CyanCore").name)

	doFirst {
		def apiJarTask = tasks.getByPath(":CyanAPI:platformRiftJarServer")
		apiID1 = "org.asf.cyan:CyanAPI-RIFT-SERVER:" + project(":CyanAPI").version + "-" + apiJarTask.getArchiveClassifier().get()
		libraries.put(apiID1, apiJarTask.archivePath);
		
		apiJarTask = tasks.getByPath(":ModKit:platformRiftJarServer")
		apiID2 = "org.asf.cyan:ModKit-RIFT-SERVER:" + project(":ModKit").version + "-" + apiJarTask.getArchiveClassifier().get()
		libraries.put(apiID2, apiJarTask.archivePath);
		
		libraries.forEach { k, v ->
			String[] information = k.split(":")
			String group = ""
			String name = information[0]
			String versionstr = ""

			if (information.length == 3) {
				group = information[0]
				name = information[1]
				versionstr = information[2]
			} else if (information.length >= 2) {
				name = information[0]
				versionstr = information[1]
			}

			if (!libnames.stream().anyMatch({ t -> t.equals(group+"."+name) })) {
				libnames.add(group+"."+name)

				def lib = "libraries/"+group.replaceAll("\\.", "/")

				lib += "/"+name+"/"+versionstr+"/"+name+"-"+versionstr+".jar"
				filepaths.put(lib, v.toPath())

				cyanclasspath += " "+lib
			}
		}
		libraries.remove(apiID1)
		libraries.remove(apiID2)

		manifest {
			attributes([
				"Specification-Title": project.name,
				"Specification-Vendor": "${authorname}",
				"Specification-Version": project.version,
				"Implementation-Title": project.name,
				"Implementation-Version": project.version,
				"Implementation-Vendor" :"${authorname}",
				"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
				"Launcher-Agent-Class": "org.asf.cyan.fluid.FluidAgent",
				"Class-Path": cyanclasspath,
				"Boot-Class-Path": bootclasspath,
				"Main-Class": project.group+"."+classWrapperServer,
				"Multi-Release": "true"
			])
		}
	}

	doLast {
		def libsDir = new File(dest, "libraries");
		if (libsDir.exists()) delete libsDir

		println " Preparing... Output directory: "+dest.getName()
		println " | Downloading remote server libraries..."
		remotelibs.forEach({ k, v ->
			File inputcache = new File(cyanCache, k)
			File downloadmarker = new File(cyanCache, k+".lck")
			if (!inputcache.exists() || downloadmarker.exists()) {
				if (!inputcache.getParentFile().exists()) inputcache.getParentFile().mkdirs();
				if (downloadmarker.exists()) downloadmarker.delete()
				downloadmarker.createNewFile()
				println " | Downloading library into cache... file: "+inputcache.getName()
				InputStream strm = v.openStream()
				if (inputcache.exists()) inputcache.delete()
				FileOutputStream strm2 = new FileOutputStream(inputcache)
				strm.transferTo(strm2)
				strm2.close()
				strm.close()
				downloadmarker.delete()
			}
			println " +-- Adding cached libary to install list... file: "+inputcache.getName()
			filepaths.put(k, inputcache.toPath())
		})

		println " |"
		println " | Installing server libraries..."
		filepaths.forEach({ k, v ->
			println " +-- Installing library... file: "+new File(dest, k).getName()
			if (!new File(dest, k).getParentFile().exists()) new File(dest, k).getParentFile().mkdirs()
			Files.copy(v, new File(dest, k).toPath());
		})

		if (modloader.startsWith("fabric-loader-")) {
			println " |"
			println " | Merging fabric loader and intermediary jars..."
			File loader = new File(dest, fabricloader)
			File intermediary = new File(dest, fabricintermediary)
			File output = new File(dest, fabricloader+".tmp")
			if (output.exists()) output.delete()

			ZipOutputStream strm = new ZipOutputStream(new FileOutputStream(output))
			ZipFile loaderJar = new ZipFile(loader)
			ZipFile intermediaryJar = new ZipFile(intermediary)

			def entries = loaderJar.entries()
			def knownentries = []
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement()
				def path = entry.getName().replaceAll("\\\\", "/") // Just in case
				if (knownentries.contains(path)) continue;
				knownentries.add(path)

				strm.putNextEntry(entry)
				loaderJar.getInputStream(entry).transferTo(strm)
				strm.closeEntry()
			}
			entries = intermediaryJar.entries()
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement()
				def path = entry.getName().replaceAll("\\\\", "/") // Just in case
				if (knownentries.contains(path)) continue;
				knownentries.add(path)

				strm.putNextEntry(entry)
				intermediaryJar.getInputStream(entry).transferTo(strm)
				strm.closeEntry()
			}
			strm.close()
			intermediaryJar.close()
			loaderJar.close()

			println " +-- Installing output jar..."
			loader.delete()
			Files.move(output.toPath(), loader.toPath())
		}

		if (!modloader.isEmpty() && modloader.startsWith("paper-")) {
			println " |"
			def paperversion = modloader.substring("paper-".length())
			println " | Downloading paper server..."

			File server = new File(org.asf.cyan.minecraft.toolkits.mtk.MinecraftInstallationToolkit.getMinecraftDirectory(), "tmp/download/paper")
			if (!server.exists())
				server.mkdirs()

			server = new File(server, "paper-current.jar")
			if (server.exists())
				server.delete()

			URL u = new URL("https://papermc.io/api/v2/projects/paper/versions/${minecraft}/builds/${paperversion}/downloads/paper-${minecraft}-${paperversion}.jar")
			InputStream strm = u.openStream()
			FileOutputStream strmOut = new FileOutputStream(server)
			strm.transferTo(strmOut)
			strm.close()
			strmOut.close()

			if (new File(dest, "paper-server-${paperversion}.jar").exists()) new File(dest, "paper-server-${paperversion}.jar").delete()
			println " +-- Installing paper server..."
			Files.copy(server.toPath(), new File(dest, "paper-server-${paperversion}.jar").toPath())

			println " |"
			println " +-- Patching vanilla server..."
			javaexec {
				workingDir dest
				classpath new File(dest, "paper-server-${paperversion}.jar")
				jvmArgs '-Dpaperclip.patchonly=true'
			}
		} else {
  			println " |"
			println " | Downloading vanilla server..."
			File server = org.asf.cyan.minecraft.toolkits.mtk.MinecraftInstallationToolkit.downloadVersionJar(org.asf.cyan.minecraft.toolkits.mtk.MinecraftVersionToolkit.getVersion(minecraft), org.asf.cyan.api.modloader.information.game.GameSide.SERVER)
			if (new File(dest, "vanilla-server.jar").exists()) new File(dest, "vanilla-server.jar").delete()
			println " +-- Installing vanilla server..."
			Files.copy(server.toPath(), new File(dest, "vanilla-server.jar").toPath())
		}
		println " +-- Server build completed."
	}
}
serverJar.dependsOn build

task serverDownloads() {}

task vanillaManifest () {
	doLast {
		project.ext.cyanVanillaManifest = cyanManifest 'CyanServerWrapper', 'CyanClientWrapper', 'Cyan %gv', 'Lapis_Ore', '', '', minecraft, minecraft, 'VANILLA' 
	}
}
serverDownloads.finalizedBy vanillaManifest

ext.cyanManifest = { wrapperServer, wrapperClient, profile, icon, modloader, modloaderVersion, inherits, mappingsVersion, platformName ->
	return kickstartManifest {
    
    	name 'Cyan'
    
    	clientMain project.group + '.' + wrapperClient
    	serverMain project.group + '.' + wrapperServer
    
    	projectVersion cyanversion
    	game minecraft
    	profileName profile
    	profileIcon icon
    	
    	loader modloader 
    	loaderVersion modloaderVersion
    	inheritsFrom inherits
    	
    	mappings mappingsVersion
    	platform platformName
    
    	wrapper project.version    	
    	
    	id '%i-cyan-%pv'
    	manifest '/org/asf/cyan/CyanWrapper/%wv-cyan-%pv/CyanWrapper-%wv-cyan-%pv-%gv-cyan-%pv.json'
    	
    	if (!modloader.equals("forge"))
    		loadFirst 'gson'
    	else
    		loadFirst 'gson', 'log4j-core', 'log4j-api'
    	
    	bootLibs 'javassist', 'reflections'
    	serverOutput 'minecraft-%i-cyan-%pv-server.jar'
    	fatServer 'org.asf.cyan:CyanWrapper', 'org.asf.cyan:Fluid', 'org.asf.cyan:CyanCore', 'org.asf.cyan:CyanComponents'
    	
    	repositories([
    		'asf': 'https://aerialworks.ddns.net/maven',
    		'central': 'https://repo1.maven.org/maven2'
    	])    	
    	
    	serverJarManifest([
    		'Launcher-Agent-Class': 'org.asf.cyan.fluid.FluidAgent',
    		'Multi-Release': 'true',
    		
    		'Specification-Title': 'CyanWrapper',
    		'Specification-Vendor': "$authorname",
    		'Specification-Version': '%pv',
    		
    		'Implementation-Title': 'CyanWrapper',
    		'Implementation-Vendor': "$authorname",
    		'Implementation-Version': '%i-cyan-%pv'
    	])
    	
    	modification 'org.asf.cyan', 'CyanCore', {
    		path 'cyan.release.ccfg'
    		method CCFG
    		
    		target 'org.asf.cyan.core.CyanInfo'
    		
    		data ([
    			'minecraftCyanVersion': '%i-cyan-%pv',
    			'minecraftVersion': '%gv',
    			'modloaderVersion': '%lv'
    		])
    	}
    	
    	modification 'org.asf.cyan', 'CyanWrapper', {
    		path 'mappings.info'
    		method REPLACE
    		contentType PLAIN
    		data '%mv'
    	}
    	
    }
}

task vanillaInstaller (type: KickStartInstallerTask, dependsOn: vanillaManifest) {
	doFirst {
    	project project.ext.cyanVanillaManifest
    }
    
    destinationDirectory = file("${buildDir}/Installers/")
    archiveBaseName = "$minecraft-cyan"
    archiveVersion = "$cyanversion"
    archiveClassifier = "installer"
}
serverDownloads.finalizedBy vanillaInstaller

if (file("../modloaderbuild.gradle").exists()) {
	

	task clearBuildFile() {
		doLast {
			file("../modloaderbuild.gradle").delete()
		}
	}	
	serverDownloads.finalizedBy clearBuildFile
}

